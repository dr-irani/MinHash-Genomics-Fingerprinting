import os
import sys
import pstats
from minhash_combined import create_k_mer_set, min_hash, calculate_jaccard, calculate_true_jaccard, containment_min_hash, estimate_edit_distance
from edit_distance_DP import edDistDp
from collections import namedtuple
import glob

def test(seq1, seq2, kmer_len, num_hash):
	'''
	Calculates true Jaccard and Jaccard estimate for all 4 algorithms.
	Returns length of sequences and the 5 Jaccard values.
	'''

	stride_len = 1
	SeqSet = namedtuple('SeqSet', 'set len')
	len_x = len(seq1)
	len_y = len(seq2)

	set1 = SeqSet(create_k_mer_set(seq1, kmer_len, stride_len), len(seq1))
	set2 = SeqSet(create_k_mer_set(seq2, kmer_len, stride_len), len(seq2))

	truejaccard = calculate_true_jaccard(set1.set, set2.set)

	fp1, hash_fxns = min_hash(set1.set, num_hash, method='khash')
	fp2, hash_fxns = min_hash(set2.set, num_hash, method='khash', hash_fxns=hash_fxns)
	jaccard1 = calculate_jaccard(num_hash, fp1, fp2)

	fp1, hash_fxns = min_hash(set1.set, num_hash, method='bottomk')
	fp2, hash_fxns = min_hash(set2.set, num_hash, method='bottomk', hash_fxns=hash_fxns)
	jaccard2 = calculate_jaccard(num_hash, fp1, fp2)

	fp1, hash_fxns = min_hash(set1.set, num_hash, method='kpartition')
	fp2, hash_fxns = min_hash(set2.set, num_hash, method='kpartition', hash_fxns=hash_fxns)
	jaccard3 = calculate_jaccard(num_hash, fp1, fp2)

	sets = sorted([set1, set2], key=lambda x: len(x.set), reverse=True)
	bloom_filter = containment_min_hash(sets[0].set)
	jaccard4 = containment_min_hash(sets[1].set, bloom_filter=bloom_filter)

	output = '{} \t {} \t {} \t {} \t {} \t {} \t {} \t'.format(len_x, len_y, truejaccard, jaccard1, jaccard2, jaccard3, jaccard4)
	return output

def ED_main_synth():
	'''
	Calculate the estimated edit distance. 3 values - lower/upper bound and our point estimate.
	Combine all outputs (jaccard similarities and true edit distance) and output to single file.
	Currently only setup for synthetic data.
	'''

	# Parameters selected
	kmer_len = 12
	num_hash = 128

	# Input Files. hash_file must have been generated by tuning_parameters.py
	hash_file = 'tuning/synth/{}_mer_{}_numhash.txt'.format(kmer_len, num_hash)
	trueED_file = 'output/synthdata_true_editdistance_single.txt'

	# Output Files.
	output_file = 'output/synthdata_estimated_editdistance.txt'

	# Calculate edit distance and output to file
	fo = open(output_file, 'w')
	output_header = ['len_x', 'len_y', 'TJ', 'J1', 'J2', 'J3', 'J4', 'trueED', 
	'TED[0]', 'TED[1]', 'TED[2]', 'ED1[0]', 'ED1[1]', 'ED1[2]', 'ED2[0]', 'ED2[1]', 'ED2[2]', 
	'ED3[0]', 'ED3[1]', 'ED3[2]', 'ED4[0]', 'ED4[1]', 'ED4[2]']
	output = '\t'.join(output_header)
	fo.write(output + '\n')

	fh = open(hash_file, 'r')
	fed = open(trueED_file, 'r')
	fh.readline()

	for i in range(60):
		temp = fh.readline()
		templist = temp.split()
		[len_x, len_y, TJ, J1, J2, J3, J4] = [float(i) for i in templist]
		len_x = int(len_x)
		len_y = int(len_y)

		trueED = int(fed.readline().strip())

		TED = estimate_edit_distance(TJ, len_x, len_y, kmer_len)
		ED1 = estimate_edit_distance(J1, len_x, len_y, kmer_len)
		ED2 = estimate_edit_distance(J2, len_x, len_y, kmer_len)
		ED3 = estimate_edit_distance(J3, len_x, len_y, kmer_len)
		ED4 = estimate_edit_distance(J4, len_x, len_y, kmer_len)

		output_list = [len_x, len_y, TJ, J1, J2, J3, J4, trueED, TED[0], TED[1], TED[2], 
		ED1[0], ED1[1], ED1[2], ED2[0], ED2[1], ED2[2], ED3[0], ED3[1], ED3[2], ED4[0], ED4[1], ED4[2]]
		output = '\t'.join(str(e) for e in output_list)
		fo.write(output + '\n')

	fo.close()

if __name__ == '__main__':
	ED_main_synth()
